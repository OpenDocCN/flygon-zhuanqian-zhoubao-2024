<h1>Youtube自动化工具分享 &amp; 开发复盘</h1>
<blockquote>来源：<a href="https://e6tnf5bko1.feishu.cn/docx/CIvld16Ydoc0Atxe72vcnvG3nre">https://e6tnf5bko1.feishu.cn/docx/CIvld16Ydoc0Atxe72vcnvG3nre</a></blockquote>
<p>大家好哇，我是龙~</p>

<p>在做Youtube shorts的过程中，大家或多或少应该会遇到以下两种情况：</p>
<p>(1) 要找对标账号，并且收集对标账号的数据（订阅数、观看数、所在地区等），用来分析这一赛道是否可以入局</p>
<p>(2) 确定对标账号之后，要下载对标账号的爆款视频，像素级分析+模仿</p>

<p>我在做Youtube的时候，也遇到了这两种情况</p>

<p>一开始，我都是手动找对标+收集对标数据，一个个复制爆款视频的链接，然后去在线视频网站下载</p>

<p>数量少的时候，这些动作可能影响不大，不太花时间，一会儿就能完成</p>

<p>但如果对标账号有几十个，要下载的爆款视频有几百个，那手动的方式显然不可行</p>

<p>往少了算，收集一个对标账号的数据要一分钟，下载一个爆款视频要一分钟，几十几百个收集需求叠加到一起，我们光收集数据和下载对标视频就得用掉好几个小时，而且都是重复的动作，效率太低</p>

<p>为了提高效率，针对这些需要，我用cursor开发了两个自动化软件，这里分享给大家：</p>
<p>(1) Youtube数据采集器：可以用Excel批量导入频道ID/频道URL/用户名，自动采集频道数据及爆款视频数据</p>
<p>(2) Youtube批量视频下载器：可以用Excel批量导入视频链接，实现全自动下载</p>

<p>废话不多说，下面给大家分享这两个工具的具体使用方法~</p>

<p>这两个软件都是在Windows系统上面开发的，不确定Mac系统是否可用，用Mac的圈友们可以尝试下</p>

<h1>工具功能说明及教程</h1>
<h2>Youtube数据采集器</h2>
<h3>功能说明</h3>
<p>Youtube数据采集器的界面如下：</p>
<p><img src="img/948cf89d6c5a63a9f24a942d4800815c.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/K7oobtKLIouUPexroORcBRFEn5L/"/></p>

<p>这个软件的原理：</p>
<p>调用Youtube官方的API来收集频道数据和视频数据，但有数额限制</p>
<p>（每天采集几千个频道/视频数据是没啥问题的，自己做的话够用了）</p>

<p>这个软件可以实现以下功能：</p>
<p>(1) 支持用Excel文件批量导入频道ID/频道URL/用户名，自动采集该频道的以下信息：</p>
<p>频道用户名、频道说明、频道订阅数、频道总观看数、频道总视频数量、频道创建时间、频道所在地区</p>
<p><img src="img/bd710742ffe637820fea4d79308f0e01.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/VObAbIxgEoRKnaxuCPbc3McCnLd/"/></p>

<p>(2) 在采集频道数据的基础上，进一步采集观看量大于X（可以自行设定）的视频的以下信息：</p>
<p>视频标题、视频说明、视频发布时间、观看量、点赞数、评论数、标签、视频URL（即视频链接）</p>
<p><img src="img/37d9b22ddd363862a4224200f98f0262.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/D0W1bpPVjoFCtwxzHRWcSchMnCb/"/></p>

<h3>使用前准备</h3>
<p>由于这个软件调用了Youtube的API，以及我们是中国大陆用户，需要魔法才能采集数据</p>

<p>因此，在使用这个软件之前，需要进行以下准备</p>

<h4>第一步，打开魔法</h4>
<p>要打开魔法之后运行这个软件，才能成功采集，但这个不方便公开分享，大家自行淘宝</p>
<p>记得一定要打开！！！</p>

<h4>【重点】第二步，获取你的Youtube API Key</h4>

<p>原始教程来自于 马哥@老馬🐎内容出海 的帖子：</p>

<p>首先，我们打开魔法（不方便公开分享，大家自行淘宝），进入这个网站：https://console.cloud.google.com/</p>

<p>然后，选择“API和服务”</p>
<p><img src="img/ff82c74ca18b82eff11a84e9030fe6cf.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/OamLbUDR7opueVxVE6OcWbLcn2d/"/></p>

<p>接着，点击“启用API和服务”</p>
<p><img src="img/1269fb5649c1807066ee021909c6fa68.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/EhVSbATlGo3BY1xIvBlceunUnWg/"/></p>

<p>下一步，在搜索框输入“Youtube”，点击Enter</p>
<p><img src="img/d75cd0811c597425768f8afe03ff94bb.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/MaZVbRyrzoNQNTxGfM5csCIFnkd/"/></p>

<p>再然后，选择第一个，“YouTube Data API v3”</p>
<p><img src="img/a6d5f62b0876225f4e07bb95b50b3797.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/Mo6ibeGf4odED6xpJN2c9HsMnGe/"/></p>

<p>点击“启动”，之后会显示“API已启用”</p>
<p><img src="img/89bde2f9b0a4bca889c76ae411469c0b.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/OkxIbd8dco7LhfxCsZdc7cZLnSe/"/></p>

<p>点击“管理”，进入下一个界面后，在左侧点击“凭据”</p>
<p><img src="img/e59cf982a48af64477de11677bd194a1.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/JD3Pbhxp0oKRfZxeAhwcuk38nCz/"/></p>

<p><img src="img/d39d75cc06e0badaa70d8c0679dc91c2.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/FzLAbTka7oGewDxHleVcqx4jnEw/"/></p>


<p>在上方点击“创建凭据”，选择“API密钥”</p>
<p><img src="img/142b3b52e7c87a7555746f530391e133.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/RN0fbxECbopn4Gx7CP8cTSjJnih/"/></p>

<p><img src="img/cd0f619482a97f7f96d7e07ac09cec16.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/XYnHbbgd0o9zPjxKlCmcdB2onse/"/></p>

<p>创建完成之后，点击“显示密钥”，然后复制里面的一大串即可</p>
<p><img src="img/bf2c57ba1d329d9a01d5305ff85d6862.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/QZcQbrryyojcljxwTouchepfnEh/"/></p>

<p><img src="img/309affa410e0bdcc9833b45c0de4ab1a.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/Z9gDbXpfZoqL5Ax2PyXc5momnSF/"/></p>

<p>复制完成之后，进入我们的软件，把这串密钥粘贴在“YouTube API Key”这一栏，选择“保存”</p>
<p>（不保存的话，下一次进行软件就需要重新输入这串密钥，点击“保存”，这串密钥就会一直使用）</p>
<p><img src="img/b18ca715e6e80a7e493f144c31ec18d1.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/Ga1SbX853obYdkxb2lRcoQLYnfd/"/></p>

<h4>【重点】第三步，获取你的代理端口地址</h4>
<p>由于我们在国内，我们还需要拿到开的魔法的端口地址，才能让软件出去采集数据</p>

<p>这一步我们可以用到chatGPT</p>

<p>进入chatGPT官网，输入以下提示词：</p>
<p>我使用的代理软件是（输入你自己用的代理软件名称），我该如何查看我的代理端口地址，我不熟悉这个代理软件，请你一步步指导我查看代理端口地址</p>

<p>这个过程中如果GPT让你提供界面图片什么的，你就截图给它，它会指导你找到端口地址</p>
<p><img src="img/6af1d9b05577ecf5fd5f578d5af48199.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/WwphbEyjvokoFLxjWJEcVleUnS6/"/></p>
<p>注意：</p>
<p>不同的软件的代理端口地址不一样，大家不要照抄我的，照抄我的很可能会报错！！！</p>
<p>想找到自己的代理端口地址，像我这样问GPT就可以</p>

<p>拿到代理端口地址之后，也是同样打开软件，在“代理地址”一栏输入并保存</p>
<p><img src="img/573a1644fcd1c6431269cab2e6681024.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/McUbbIzDoo3GegxUxEacsLQAnFb/"/></p>

<h4>第四步，准备一个提供频道ID/频道URL/用户名的Excel文件</h4>
<p>这个软件支持以下三种格式来输入频道：</p>
<p>①频道ID：UC-PzuWWwlOMynKP7w2BvM6g（以UC开头），可以按下图的方式获取</p>
<p><img src="img/339f24c5301255a9f1d4559b042591e4.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/RDuBbgA8VoKyGTxXpCmcTsBVnMc/"/></p>

<p>②频道URL：https://www.youtube.com/@CalmCity-channel，格式为“https://www.youtube.com/@username”</p>
<p>可以按下图方式获取</p>
<p><img src="img/dbb01a5cb4287f6a062d78f98b65f679.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/TnrEbq45GoTEvox6iwcctYmdnRd/"/></p>

<p><img src="img/6fb74a4b45c64941e599717350054f28.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/K1mcbLB9qoNtjExLLhkc8yzknwh/"/></p>

<p>③用户名：@CalmCity-channel，格式为“@username”，可以按下图方式获取</p>
<p><img src="img/b3af59f29c8882467c1bb0de64d9761f.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/OwN5bskGko3vobxhoAUcJKKenzf/"/></p>

<p>这三种方式中，频道ID（UC开头）最精确，但不好获取；频道URL比较常用，精确度一般情况下都够用；用户名最方便，但是精确度最差。首推频道URL和频道ID这两种格式</p>

<p>说明：</p>
<p>我在收集https://www.youtube.com/@HealingWithMe.这个频道的数据时，由于用的是URL格式，并且还有其他频道的URL和这个频道非常像，所以导致一直收集不到正确的数据，最后是用了频道ID的方法才采集到正确的数据，但这种情况很少出现（这个频道比较特殊，它的URL最后有个"."号，导致程序识别容易出问题），所以，如果大家追求绝对精确，就用频道ID，但大多数情况下频道URL也够用</p>


<p>收集好对应格式的频道链接之后，放进一个Excel文件里。Excel文件的格式如下图，频道链接放在第一列，我标黄的那个格子不要放，程序识别不出来，那个格子写不写东西都无所谓</p>
<p><img src="img/fa8a09ac5958bc36ef6e99246d7e7554.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/BxhFbg5qMoKBW6xp8mxctsU0njf/"/></p>

<h3>使用指引</h3>
<p>完成以上准备之后，就打开软件</p>

<p>① 输入API Key（并保存）</p>
<p><img src="img/f56acad80497efac44f5fab0fdb5f8f3.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/JYoGbOMAKo6wtcx3rEYcM3SSnad/"/></p>

<p>② 输入代理地址（并保存）</p>
<p><img src="img/ee444cc0637644beef69b6cb91a75a96.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/CYD9bP4qno0va0xaGaucJMREnvf/"/></p>

<p>③ 设定想要收集的视频数据下限（程序只会收集大于你设定的观看量的视频信息）</p>
<p><img src="img/606154a61645a91a3b34ba6689a24513.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/Y1GMbxlrhopfZLxFUbLcpbNgnNc/"/></p>

<p>④ 选择Excel文件所在的路径</p>
<p><img src="img/298e98d6994dcb01485b9e874a8152c2.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/IzAJbhomQo0pDCxe78ZcPy1lnjg/"/></p>

<p>⑤ 选择收集好的视频信息的保存路径（收集的视频信息会以Excel文件的形式保存）</p>
<p><img src="img/9ee972ac53192c556f85f485ce7f7b1a.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/Bpz0biqyNoAntBxZx3EcHfJinUc/"/></p>

<p>⑥ 点击“开始采集”，采集过程中的数据也会显示在软件上</p>
<p>（如：最后一共采集了多少个符合要求的视频、文件保持位置等）</p>
<p><img src="img/ec90b0918d8d2c0212b3a81e3d7b6485.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/QT7Rbfg3doX5IhxpA3scT2Gsnld/"/></p>

<p>注意：</p>
<p>收集的频道数据会保存在你提供频道链接的Excel文件所在的位置，而视频数据则会保存在你选择的保存路径中</p>

<p>频道数据保存示例（文件命名：channel_updated_具体收集时间 年月日时分秒）：</p>
<p><img src="img/8d64aa2055916e77bd0b9366a28a4092.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/HGPHbjp30ooDU9xET8ccpbsAnVd/"/></p>

<p>视频数据保存示例（文件命名：@用户名_video）：</p>
<p><img src="img/07b89a8e40bd45cee5c9efabda1d706c.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/WBoRbvom8opBcrxTBybcrupJnAg/"/></p>

<h3>软件地址</h3>
<p>通过百度网盘分享的文件：Youtube数据采集器 2.0.zip</p>
<p>链接：https://pan.baidu.com/s/1PNbXdqmZPrjzQLi2cUYMUA?pwd=v8dk</p>
<p>提取码：v8dk</p>

<h3>源代码</h3>
<h4>主程序</h4>
<pre>import os
import logging
from datetime import datetime
import pandas as pd
from googleapiclient.discovery import build
from tenacity import retry, stop_after_attempt, wait_exponential


class YouTubeDataCollector:
    def __init__(self, api_key, view_threshold=1000000, proxy=None, save_path=None, logger_callback=None):
        """
        初始化收集器
        :param api_key: YouTube API密钥
        :param view_threshold: 视频观看量阈值
        :param proxy: 代理设置
        :param save_path: 数据保存路径
        :param logger_callback: 日志回调函数
        """
        # 配置代理
        if proxy:
            os.environ['HTTP_PROXY'] = proxy
            os.environ['HTTPS_PROXY'] = proxy

        self.api_key = api_key
        self.youtube = build('youtube', 'v3', developerKey=api_key)
        self.logger_callback = logger_callback
        self.view_threshold = view_threshold  # 设置观看量阈值

        # 验证并设置保存路径
        if not save_path:
            raise ValueError("必须指定保存路径")
        self.video_save_path = save_path

        # 设置日志路径为保存路径下的 logs 文件夹
        self.log_path = os.path.join(self.video_save_path, "logs")

        # 配置日志
        self.setup_logging()

    def setup_logging(self):
        """设置日志"""
        # 创建日志目录
        os.makedirs(self.log_path, exist_ok=True)
        log_file = os.path.join(self.log_path, f'youtube_collector_{datetime.now().strftime("%Y%m%d")}.log')

        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)

    def log_message(self, message):
        """统一的日志记录函数"""
        self.logger.info(message)
        if self.logger_callback:
            self.logger_callback(message)

    def extract_channel_info(self, input_str):
        """
        从多种输入格式中提取频道信息
        支持的格式：
        1. 频道ID (UC...)
        2. 频道URL (https://www.youtube.com/@...)
        3. 频道用户名 (@...)
        """
        try:
            self.log_message(f"正在处理输入: {input_str}")

            # 1. 检查是否是频道ID (UC开头)
            if input_str.startswith('UC'):
                self.log_message("检测到频道ID格式")
                return self.get_channel_by_id(input_str)

            # 2. 检查是否是频道URL或用户名
            if '/@' in input_str or input_str.startswith('@'):
                self.log_message("检测到频道用户名格式")
                username = input_str.split('/@')[-1].split('/')[0].strip() if '/@' in input_str else input_str.strip()
                return self.get_channel_by_username(username)

            self.log_message(f"无法识别的输入格式: {input_str}")
            return None

        except Exception as e:
            self.log_message(f"提取频道信息时出错: {str(e)}")
            return None

    def get_channel_by_id(self, channel_id):
        """直接通过频道ID获取信息"""
        try:
            request = self.youtube.channels().list(
                part="snippet,statistics,brandingSettings",
                id=channel_id
            )
            response = request.execute()

            if response.get('items'):
                channel = response['items'][0]
                self.log_message(f"成功获取频道信息: {channel['snippet']['title']}")
                return channel
            else:
                self.log_message(f"未找到频道ID: {channel_id}")
                return None

        except Exception as e:
            self.log_message(f"获取频道信息时出错: {str(e)}")
            return None

    def get_channel_by_username(self, username):
        """通过用户名获取频道信息"""
        try:
            # 移除@符号（如果存在）
            clean_username = username.lstrip('@')
            self.log_message(f"正在获取频道信息，用户名: {clean_username}")

            # 使用搜索方法查找频道
            try:
                request = self.youtube.search().list(
                    part="snippet",
                    q=clean_username,
                    type="channel",
                    maxResults=5
                )
                response = request.execute()

                if response.get('items'):
                    # 获取第一个搜索结果的频道ID
                    channel_id = response['items'][0]['id']['channelId']

                    # 使用频道ID获取完整信息
                    channel_request = self.youtube.channels().list(
                        part="snippet,statistics,brandingSettings",
                        id=channel_id
                    )
                    channel_response = channel_request.execute()

                    if channel_response.get('items'):
                        channel = channel_response['items'][0]
                        self.log_message(f"成功找到频道: {channel['snippet']['title']}")
                        return channel

            except Exception as e:
                self.log_message(f"搜索频道时出错: {str(e)}")

            return None

        except Exception as e:
            self.log_message(f"获取频道信息时出错: {str(e)}")
            return None

    def get_channel_data(self, input_str):
        """获取频道数据的主方法"""
        try:
            channel = self.extract_channel_info(input_str)
            if not channel:
                self.log_message(f"无法获取频道信息: {input_str}")
                return None

            channel_data = {
                'channel_name': channel['snippet']['title'],
                'description': channel['snippet']['description'],
                'subscriber_count': channel['statistics'].get('subscriberCount', 'N/A'),
                'view_count': channel['statistics'].get('viewCount', 'N/A'),
                'video_count': channel['statistics'].get('videoCount', 'N/A'),  # 添加总视频数
                'created_date': channel['snippet']['publishedAt'],
                'country': channel['snippet'].get('country', 'Not specified'),
                'channel_id': channel['id']
            }

            self.log_message(f"成功获取频道信息: {channel_data['channel_name']}")
            self.log_message(f"频道总视频数: {channel_data['video_count']}")  # 添加日志输出
            return channel_data

        except Exception as e:
            self.log_message(f"获取频道数据时出错: {str(e)}")
            raise

    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))
    def get_videos_details(self, video_ids):
        """获取视频详细信息"""
        try:
            # 每次最多请求50个视频的详情
            results = []
            for i in range(0, len(video_ids), 50):
                batch = video_ids[i:i + 50]
                request = self.youtube.videos().list(
                    part="snippet,statistics",  # statistics 部分包含了点赞数和评论数
                    id=','.join(batch)
                )
                response = request.execute()
                results.extend(response['items'])
                self.log_message(f"成功获取一批 {len(batch)} 个视频的详情")

            return results
        except Exception as e:
            self.log_message(f"获取视频详情时出错: {str(e)}")
            raise

    def get_channel_videos(self, channel_id):
        """获取频道的所有符合条件的视频"""
        videos = []
        next_page_token = None
        total_videos_found = 0
        total_videos_filtered = 0
        page_count = 0

        try:
            while True:  # 移除页数限制，持续获取直到没有更多视频
                try:
                    self.log_message(f"正在获取频道 {channel_id} 的视频列表... (第 {page_count + 1} 页)")
                    request = self.youtube.search().list(
                        part="id",
                        channelId=channel_id,
                        maxResults=50,  # YouTube API 的最大限制
                        pageToken=next_page_token,
                        type="video",
                        order="date"  # 按日期排序，确保获取所有视频
                    )
                    response = request.execute()

                    if not response.get('items'):
                        self.log_message("没有找到更多视频")
                        break

                    video_ids = [item['id']['videoId'] for item in response['items']]
                    total_videos_found += len(video_ids)
                    self.log_message(f"本页找到 {len(video_ids)} 个视频")

                    # 获取视频详情
                    try:
                        video_details = self.get_videos_details(video_ids)
                        self.log_message(f"成功获取 {len(video_details)} 个视频的详细信息")

                        # 筛选观看数大于阈值的视频
                        filtered_videos = []
                        for video in video_details:
                            try:
                                view_count = int(video['statistics'].get('viewCount', 0))
                                self.log_message(f"视频 {video['id']} 的观看数为: {view_count}")
                                if view_count &gt;= self.view_threshold:
                                    filtered_videos.append(video)
                                    self.log_message(
                                        f"视频 {video['id']} 观看数 {view_count} 符合条件（大于等于 {self.view_threshold}）")
                                else:
                                    self.log_message(
                                        f"视频 {video['id']} 观看数 {view_count} 不符合条件（小于 {self.view_threshold}）")
                            except ValueError:
                                self.log_message(f"视频 {video['id']} 的观看数无效")
                                continue

                        total_videos_filtered += len(filtered_videos)
                        self.log_message(f"本页筛选出 {len(filtered_videos)} 个符合条件的视频")
                        videos.extend(filtered_videos)

                    except Exception as e:
                        self.log_message(f"获取视频详情时出错: {str(e)}")
                        if "quotaExceeded" in str(e):
                            raise
                        continue

                    next_page_token = response.get('nextPageToken')
                    if not next_page_token:
                        self.log_message("没有更多页面，视频获取完成")
                        break

                    page_count += 1
                    self.log_message(f"准备获取下一页数据 (当前第 {page_count} 页)")

                except Exception as e:
                    self.log_message(f"获取频道视频列表时出错: {str(e)}")
                    if "quotaExceeded" in str(e):
                        raise
                    continue

            self.log_message(f"\n频道视频获取统计:")
            self.log_message(f"- 总共找到的视频数: {total_videos_found}")
            self.log_message(f"- 符合观看数阈值({self.view_threshold})的视频数: {total_videos_filtered}")
            self.log_message(f"- 最终收集到的视频数: {len(videos)}")
            self.log_message(f"- 处理的页数: {page_count}")

            return videos

        except Exception as e:
            self.log_message(f"获取频道视频时出错: {str(e)}")
            raise

    def save_videos_to_excel(self, channel_id, videos, original_url):
        """将视频数据保存到Excel"""
        try:
            video_data = []
            processed_video_ids = set()

            # 从URL中提取用户名
            username = None
            if '/@' in original_url:
                username = original_url.split('/@')[1].split('/')[0].strip()

            for video in videos:
                video_id = video['id']
                if video_id in processed_video_ids:
                    self.log_message(f"跳过重复视频ID: {video_id}")
                    continue

                processed_video_ids.add(video_id)
                video_data.append({
                    'title': video['snippet']['title'],
                    'description': video['snippet']['description'],
                    'published_at': video['snippet']['publishedAt'],
                    'view_count': video['statistics'].get('viewCount', 'N/A'),
                    'like_count': video['statistics'].get('likeCount', 'N/A'),
                    'comment_count': video['statistics'].get('commentCount', 'N/A'),
                    'tags': ','.join(video['snippet'].get('tags', [])),
                    'url': f"https://www.youtube.com/watch?v={video_id}",
                    'video_id': video_id
                })

            if video_data:
                # 转换为DataFrame
                df = pd.DataFrame(video_data)

                # 记录原始数据
                original_count = len(df)
                self.log_message(f"原始数据数量: {original_count}")

                # 只基于video_id去重
                df = df.drop_duplicates(subset=['video_id'], keep='first')

                # 记录清洗后的数据
                cleaned_count = len(df)
                self.log_message(f"清洗后数据数量: {cleaned_count}")

                if original_count &gt; cleaned_count:
                    self.log_message(f"清除了 {original_count - cleaned_count} 条重复数据")
                    duplicate_ids = df['video_id'].value_counts()[df['video_id'].value_counts() &gt; 1].index
                    if len(duplicate_ids) &gt; 0:
                        self.log_message(f"重复的视频ID: {list(duplicate_ids)}")

                # 删除video_id列
                df = df.drop('video_id', axis=1)

                # 使用用户名作为文件名，如果无法获取用户名则使用频道ID
                if username:
                    filename = f"{username}_videos.xlsx"
                else:
                    filename = f"{channel_id}_videos.xlsx"

                output_path = os.path.join(self.video_save_path, filename)
                df.to_excel(output_path, index=False)
                self.log_message(f"视频数据已保存到: {output_path}")

            else:
                self.log_message("没有数据需要保存")

        except Exception as e:
            self.log_message(f"保存视频数据时出错: {str(e)}")
            raise

    def process_excel_file(self, excel_path):
        """处理Excel文件"""
        try:
            # 读取Excel文件，确保不跳过任何行
            try:
                df = pd.read_excel(excel_path, dtype=str)
                df = df.dropna(how='all')
                df = df.reset_index(drop=True)

                self.log_message(f"成功读取Excel文件，共有 {len(df)} 个频道待处理")
                self.log_message(f"读取到的URL列表：{df.iloc[:, 0].tolist()}")
            except Exception as e:
                self.log_message(f"读取Excel文件失败: {str(e)}")
                return

            if df.empty:
                self.log_message("Excel文件为空")
                return

            # 确保所需的列存在
            required_columns = ['channel_name', 'description', 'subscriber_count',
                                'view_count', 'video_count', 'created_date', 'country']  # 添加 video_count
            for col in required_columns:
                if col not in df.columns:
                    df[col] = ''

            channel_urls = df.iloc[:, 0].astype(str).tolist()
            success_count = 0

            for idx, url in enumerate(channel_urls):
                if pd.isna(url) or url.strip() == '':
                    self.log_message(f"第 {idx + 1} 行的URL为空，已跳过")
                    continue

                try:
                    self.log_message(f"正在处理第 {idx + 1}/{len(channel_urls)} 个频道: {url}")

                    # 使用新的get_channel_data方法
                    channel_data = self.get_channel_data(url)
                    if channel_data:
                        for col, value in channel_data.items():
                            if col != 'channel_id':
                                df.loc[idx, col] = value

                        self.log_message(f"开始获取频道 {url} 的视频数据...")
                        videos = self.get_channel_videos(channel_data['channel_id'])
                        if videos:
                            self.save_videos_to_excel(channel_data['channel_id'], videos, url)
                            self.log_message(f"成功保存频道 {url} 的视频数据，共 {len(videos)} 个视频")
                            # 添加统计信息
                            self.log_message(f"频道统计信息:")
                            self.log_message(f"- 总视频数: {channel_data['video_count']}")
                            self.log_message(f"- 符合观看量阈值的视频数: {len(videos)}")
                        else:
                            self.log_message(f"频道 {url} 没有符合条件的视频（观看数 &gt;= {self.view_threshold}）")

                        success_count += 1
                    else:
                        self.log_message(f"无法获取频道数据: {url}")

                except Exception as e:
                    self.log_message(f"处理频道 {url} 时出错: {str(e)}")
                    continue

            self.log_message(f"总共处理了 {len(channel_urls)} 个频道，成功 {success_count} 个")

            # 保存更新后的Excel文件
            try:
                base_path = os.path.splitext(excel_path)[0]
                current_time = datetime.now().strftime("%Y%m%d_%H%M%S")
                new_excel_path = f"{base_path}_updated_{current_time}.xlsx"

                df.to_excel(new_excel_path, index=False)
                self.log_message(f"数据已保存到新文件: {new_excel_path}")

            except Exception as e:
                self.log_message(f"保存Excel文件时出错: {str(e)}")
                desktop_path = os.path.join(os.path.expanduser("~"), "Desktop")
                backup_file = os.path.join(desktop_path, f"youtube_data_backup_{current_time}.xlsx")
                try:
                    df.to_excel(backup_file, index=False)
                    self.log_message(f"数据已保存到备份文件: {backup_file}")
                except Exception as e2:
                    self.log_message(f"保存备份文件也失败: {str(e2)}")
                    raise

        except Exception as e:
            self.log_message(f"处理Excel文件时出错: {str(e)}")
            raise

    def run(self, excel_path):
        """运行主程序"""
        try:
            self.log_message("开始处理数据...")
            self.process_excel_file(excel_path)
            self.log_message("数据处理完成！")
        except Exception as e:
            self.log_message(f"程序运行出错: {str(e)}")
            raise</pre>
<h4>UI</h4>
<pre>class YouTubeCollectorGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("YouTube数据采集器")
        self.root.geometry("700x650")

        # 配置文件路径
        self.config_file = 'collector_config.json'
        # 加载配置
        self.load_config()

        # 创建消息队列用于更新进度
        self.message_queue = queue.Queue()

        # 创建主框架
        self.main_frame = ttk.Frame(root, padding="10")
        self.main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # API Key 输入、保存和清空按钮
        ttk.Label(self.main_frame, text="YouTube API Key:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.api_key_var = tk.StringVar(value=self.saved_api_key)
        self.api_key_entry = ttk.Entry(self.main_frame, textvariable=self.api_key_var, width=50)
        self.api_key_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), pady=5)

        # 创建一个框架来容纳API Key的按钮
        api_key_buttons_frame = ttk.Frame(self.main_frame)
        api_key_buttons_frame.grid(row=0, column=2, sticky=tk.W, padx=5, pady=5)

        self.save_api_key_button = ttk.Button(api_key_buttons_frame, text="保存", command=self.save_api_key)
        self.save_api_key_button.pack(side=tk.LEFT, padx=(0, 5))

        self.clear_api_key_button = ttk.Button(api_key_buttons_frame, text="清空", command=self.clear_api_key)
        self.clear_api_key_button.pack(side=tk.LEFT)

        # 代理设置、保存和清空按钮
        ttk.Label(self.main_frame, text="代理地址:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.proxy_var = tk.StringVar(value=self.saved_proxy)
        self.proxy_entry = ttk.Entry(self.main_frame, textvariable=self.proxy_var, width=50)
        self.proxy_entry.grid(row=1, column=1, sticky=(tk.W, tk.E), pady=5)

        # 创建一个框架来容纳代理地址的按钮
        proxy_buttons_frame = ttk.Frame(self.main_frame)
        proxy_buttons_frame.grid(row=1, column=2, sticky=tk.W, padx=5, pady=5)

        self.save_proxy_button = ttk.Button(proxy_buttons_frame, text="保存", command=self.save_proxy)
        self.save_proxy_button.pack(side=tk.LEFT, padx=(0, 5))

        self.clear_proxy_button = ttk.Button(proxy_buttons_frame, text="清空", command=self.clear_proxy)
        self.clear_proxy_button.pack(side=tk.LEFT)

        # 观看量阈值设置 (修改这部分)
        ttk.Label(self.main_frame, text="收集观看量大于").grid(row=2, column=0, sticky=tk.W, pady=5)
        self.threshold_var = tk.StringVar()  # 不设置默认值
        self.threshold_entry = ttk.Entry(self.main_frame, textvariable=self.threshold_var, width=15)
        self.threshold_entry.grid(row=2, column=1, sticky=tk.W, pady=5)
        ttk.Label(self.main_frame, text="的视频信息").grid(row=2, column=1, sticky=tk.W, padx=(120,0), pady=5)

        # Excel文件选择
        ttk.Label(self.main_frame, text="选择提供频道的Excel文件:").grid(row=3, column=0, sticky=tk.W, pady=5)
        self.excel_path_var = tk.StringVar()
        self.excel_path_entry = ttk.Entry(self.main_frame, textvariable=self.excel_path_var, width=40)
        self.excel_path_entry.grid(row=3, column=1, sticky=(tk.W, tk.E), pady=5)
        self.browse_button = ttk.Button(self.main_frame, text="浏览", command=self.browse_excel_file)
        self.browse_button.grid(row=3, column=2, sticky=tk.W, padx=5, pady=5)

        # 视频数据保存路径选择
        ttk.Label(self.main_frame, text="保存路径:").grid(row=4, column=0, sticky=tk.W, pady=5)
        self.save_path_var = tk.StringVar()
        self.save_path_entry = ttk.Entry(self.main_frame, textvariable=self.save_path_var, width=40)
        self.save_path_entry.grid(row=4, column=1, sticky=(tk.W, tk.E), pady=5)
        self.save_path_button = ttk.Button(self.main_frame, text="选择", command=self.browse_save_path)
        self.save_path_button.grid(row=4, column=2, sticky=tk.W, padx=5, pady=5)

        # 进度显示文本框
        self.progress_text = tk.Text(self.main_frame, height=15, width=60)
        self.progress_text.grid(row=5, column=0, columnspan=3, pady=10)

        # 滚动条
        scrollbar = ttk.Scrollbar(self.main_frame, orient=tk.VERTICAL, command=self.progress_text.yview)
        scrollbar.grid(row=5, column=3, sticky=(tk.N, tk.S))
        self.progress_text['yscrollcommand'] = scrollbar.set

        # 进度条
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(self.main_frame, length=400, mode='determinate',
                                            variable=self.progress_var)
        self.progress_bar.grid(row=6, column=0, columnspan=3, pady=10)

        # 开始按钮
        self.start_button = ttk.Button(self.main_frame, text="开始采集", command=self.start_collection)
        self.start_button.grid(row=7, column=0, columnspan=3, pady=10)

        # 定期检查消息队列
        self.check_message_queue()

    def load_config(self):
        """加载配置文件"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    config = json.load(f)
                    self.saved_api_key = config.get('api_key', '')
                    self.saved_proxy = config.get('proxy', '')  # 默认为空字符串
            else:
                self.saved_api_key = ''
                self.saved_proxy = ''  # 默认为空字符串
        except Exception as e:
            self.saved_api_key = ''
            self.saved_proxy = ''  # 默认为空字符串

    def clear_api_key(self):
        """清空API Key"""
        try:
            config = self.load_current_config()
            if 'api_key' in config:
                del config['api_key']
            self.save_config(config)
            self.api_key_var.set('')  # 清空输入框
            self.saved_api_key = ''  # 清空保存的值
            messagebox.showinfo("成功", "API Key已清空")
        except Exception as e:
            messagebox.showerror("错误", f"清空API Key失败: {str(e)}")

    def clear_proxy(self):
        """清空代理地址"""
        try:
            config = self.load_current_config()
            if 'proxy' in config:
                del config['proxy']
            self.save_config(config)
            self.proxy_var.set('')  # 清空输入框
            self.saved_proxy = ''  # 清空保存的值
            messagebox.showinfo("成功", "代理地址已清空")
        except Exception as e:
            messagebox.showerror("错误", f"清空代理地址失败: {str(e)}")

    def save_api_key(self):
        """保存API Key到配置文件"""
        api_key = self.api_key_var.get().strip()
        if not api_key:
            messagebox.showerror("错误", "API Key不能为空")
            return

        config = self.load_current_config()
        config['api_key'] = api_key
        self.save_config(config)
        self.saved_api_key = api_key  # 更新保存的值
        messagebox.showinfo("成功", "API Key已保存")

    def save_proxy(self):
        """保存代理地址到配置文件"""
        proxy = self.proxy_var.get().strip()
        if not proxy:
            messagebox.showerror("错误", "代理地址不能为空")
            return

        config = self.load_current_config()
        config['proxy'] = proxy
        self.save_config(config)
        self.saved_proxy = proxy  # 更新保存的值
        messagebox.showinfo("成功", "代理地址已保存")

    def load_current_config(self):
        """加载当前配置"""
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {}

    def save_config(self, config):
        """保存配置到文件"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(config, f)
        except Exception as e:
            messagebox.showerror("错误", f"保存配置文件失败: {str(e)}")

    def browse_excel_file(self):
        """选择Excel文件"""
        filename = filedialog.askopenfilename(
            title="选择Excel文件",
            filetypes=[("Excel files", "*.xlsx *.xls")]
        )
        if filename:
            self.excel_path_var.set(filename)

    def browse_save_path(self):
        """选择保存路径"""
        dirname = filedialog.askdirectory(title="选择保存路径")
        if dirname:
            self.save_path_var.set(dirname)

    def update_progress(self, message):
        """更新进度显示"""
        self.progress_text.insert(tk.END, message + "\n")
        self.progress_text.see(tk.END)

    def check_message_queue(self):
        """检查消息队列并更新UI"""
        try:
            while True:
                message = self.message_queue.get_nowait()
                self.update_progress(message)
        except queue.Empty:
            pass
        finally:
            self.root.after(100, self.check_message_queue)

    def custom_logger(self, message):
        """自定义日志处理函数"""
        self.message_queue.put(message)

    def validate_threshold(self):
        """验证观看量阈值"""
        threshold = self.threshold_var.get().strip()
        if not threshold:
            messagebox.showerror("错误", "请输入观看量阈值")
            return False
        if not threshold.isdigit():
            messagebox.showerror("错误", "观看量阈值必须为数字")
            return False
        return True

    def start_collection(self):
        """开始数据采集"""
        # 验证输入
        if not self.api_key_var.get().strip():
            messagebox.showerror("错误", "请输入YouTube API Key")
            return
        if not self.excel_path_var.get().strip():
            messagebox.showerror("错误", "请选择Excel文件")
            return
        if not os.path.exists(self.excel_path_var.get()):
            messagebox.showerror("错误", "Excel文件不存在")
            return
        if not self.save_path_var.get().strip():
            messagebox.showerror("错误", "请选择保存路径")
            return
        if not self.validate_threshold():
            return

        save_path = self.save_path_var.get().strip()
        if not os.path.exists(save_path):
            try:
                os.makedirs(save_path)
            except Exception as e:
                messagebox.showerror("错误", f"无法创建保存路径: {str(e)}")
                return

        # 禁用按钮和输入框
        self.start_button.state(['disabled'])
        self.api_key_entry.state(['disabled'])
        self.proxy_entry.state(['disabled'])
        self.excel_path_entry.state(['disabled'])
        self.save_path_entry.state(['disabled'])
        self.browse_button.state(['disabled'])
        self.save_path_button.state(['disabled'])

        # 清空进度显示
        self.progress_text.delete(1.0, tk.END)
        self.progress_var.set(0)

        # 创建并启动采集线程
        thread = threading.Thread(target=self.run_collection)
        thread.daemon = True
        thread.start()

    def run_collection(self):
        """运行采集程序"""
        try:
            # 创建采集器实例，确保正确传入观看量阈值
            collector = YouTubeDataCollector(
                api_key=self.api_key_var.get().strip(),
                view_threshold=int(self.threshold_var.get().strip()),  # 确保正确传入阈值
                proxy=self.proxy_var.get().strip(),
                save_path=self.save_path_var.get().strip(),
                logger_callback=self.custom_logger
            )

            # 运行采集
            collector.run(self.excel_path_var.get())

            # 完成后的处理
            self.message_queue.put("采集完成！")
            self.root.after(0, self.collection_completed)

        except Exception as e:
            error_message = str(e)
            if "配额已用完" in error_message or "quotaExceeded" in error_message:
                detailed_message = (
                    "YouTube API 配额已用完！\n\n"
                    "解决方法：\n"
                    "1. 等待24小时后再试\n"
                    "2. 使用新的 API Key\n"
                    "3. 增加项目的配额限制\n\n"
                    "建议：每个 API Key 每天可以处理约 100 个频道的数据"
                )
                self.message_queue.put(f"错误: {detailed_message}")
                self.root.after(0, lambda: messagebox.showerror("API 配额超限", detailed_message))
            else:
                self.message_queue.put(f"错误: {error_message}")
            self.root.after(0, lambda: self.collection_error(error_message))

    def collection_error(self, error_message):
        """采集出错后的处理"""
        if "配额已用完" not in error_message and "quotaExceeded" not in error_message:
            messagebox.showerror("错误", error_message)
        self.enable_inputs()

    def collection_completed(self):
        """采集完成后的处理"""
        messagebox.showinfo("完成", "数据采集已完成！")
        self.enable_inputs()

    def collection_error(self, error_message):
        """采集出错后的处理"""
        messagebox.showerror("错误", error_message)
        self.enable_inputs()

    def enable_inputs(self):
        """启用所有输入控件"""
        self.start_button.state(['!disabled'])
        self.api_key_entry.state(['!disabled'])
        self.proxy_entry.state(['!disabled'])
        self.excel_path_entry.state(['!disabled'])
        self.save_path_entry.state(['!disabled'])
        self.browse_button.state(['!disabled'])
        self.save_path_button.state(['!disabled'])


def main():
    root = tk.Tk()
    app = YouTubeCollectorGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()</pre>
<h2>Youtube批量视频下载器（已更新）</h2>
<h3>功能说明</h3>
<p>Youtube批量视频下载器的界面如下：</p>
<p><img src="img/2d1d02d6344551b2290199ec3a7ae1ab.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/SWD5b0ajgoZCgIx9bRzch5Cqn5f/"/></p>
<p>这个软件的原理：</p>
<p>调用python的yt_dlp库，从而实现本地批量下载youtube视频（无数量限制），但是要设置代理端口和cookies</p>

<p>这个软件可以实现以下功能：</p>
<p>(1) 支持用Excel文件批量导入视频链接，并实现批量自动下载</p>
<p>(2) 支持自选分辨率（720p、1080p、1440p）</p>
<p>(3) 支持调整下载视频的数量（如果你的Excel文件里有5个视频链接，可以选择下载前n个，从上到下依次下载）</p>

<h3>使用前准备</h3>
<h4>第一步，打开魔法</h4>
<p>上面讲过，不再赘述</p>

<h4>第二步，获取你的代理端口地址</h4>
<p>【点击跳转教程】</p>

<h4>【重点】第三步，获取你的cookies</h4>
<p>①下载获取cookies的插件：</p>
<p>https://chromewebstore.google.com/detail/cookie-editor/hlkenndednhfkekhgcdicdfddnkalmdm</p>

<p>②下载完之后，点击右上角的拼图图标，把插件固定在状态栏（Edge操作也差不多）</p>
<p><img src="img/ae13e12899f457723b6af6446ffb49c9.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/ScPAbR22doQ2nYxFYd6c1vuQnhh/"/></p>

<p><img src="img/cc055679b33120516f582faebdbac3fc.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/QaP9bPEoQovFiNxTcDecgdvonZb/"/></p>

<p><img src="img/e32f1bd092602aecf6049cea0168740d.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/ByVebiHfNov49YxCHabc4Fo0njc/"/></p>

<p>③进入Youtube首页：https://www.youtube.com/，登录自己的账号，然后点击右上角的插件选择“This Site”</p>
<p><img src="img/391a267c580e510fefeac2031174e9e5.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/JEZ3b5nDvoLLLrxYAsMcGavWnih/"/></p>

<p><img src="img/55f592c2337596963fcdf6ecc84371cc.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/ZoRDbHB03oFmM4xFZLicQkFlniW/"/></p>

<p>④点击插件右下角图标“Export”，选择“Netscape”，就把cookies复制到粘贴板了</p>
<p><img src="img/ad2f1b1a93f783191f4d8f7579cb9dea.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/Qoo4bHX0CoqdQxxPpK6ckdQhnCe/"/></p>

<p><img src="img/2057da4af167e5afa2a365ec9ed6ac32.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/CSnxbLF77oxErZxM0rec0s6HnQN/"/></p>


<p>⑤在随便一个位置，鼠标右键新建一个.txt文件（命名随意），把刚刚复制的cookies粘贴进去，Ctrl+S保存</p>
<p><img src="img/1e157274acbfd6b5a451c648a3ca9bc5.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/HCp8bwCNro3L8xxfZQqcjXManuf/"/></p>

<p><img src="img/e13f61bba052623fb6b7350d87dff673.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/Elg4bBxKFoqz3yxRsdYcBwY6nAd/"/></p>


<p>⑥打开软件，在“Cookies文件”这一栏选中刚刚放有cookies的txt文件即可</p>
<p><img src="img/153cec07f22c7a59709c7c61599e2bf9.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/C0ztbxcT4ofoMhxOjtlclpDWnWh/"/></p>

<p>注意：</p>
<p>cookies每隔两周要更换一次，同样是按照上述操作流程，cookies准备过期的时候，程序会自动提醒</p>

<h4>【重点】第四步，准备一个提供视频链接的文件</h4>
<p>视频链接可以通过以下方式获取：</p>
<p>①用Youtube数据采集器收集的链接，可以无缝衔接批量下载</p>
<p>②普通视频获取方式</p>
<p><img src="img/fe059b6d9eff38d81ec8155442d6fac9.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/L8XXbR492oBn19xwgAfckdMbnsf/"/></p>

<p><img src="img/837172c07c262777c44b38b3d7e1a383.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/Z0pHbC9VYoIiXlxqSBFccMqDnWb/"/></p>
<p><img src="img/f8742a117e01fcd2075eb98bda27427e.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/ZN4SbcxiOo0QIkxWq5fcEgAQnAd/"/></p>

<p>③shorts获取方式</p>
<p><img src="img/3bdf86cb3bf530410615556498928fa1.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/Nc28bTZKdoCBa0xtjmfcwpsNnpd/"/></p>


<p><img src="img/32428742929d3f427403a4847ed5c05c.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/UCE4bq9jqoOBJJxloPbcxyLsnQd/"/></p>
<p><img src="img/47ea4754542c680248c9e2578b653cdb.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/SmnTbCsEAoXNZaxUwVocg4xgngf/"/></p>

<p>Excel文件的格式如下图，视频链接放在第几列都可以，但是放视频链接的那一列，最上面一格一定要输入“URL"或者”url“，不然程序识别不到！！！</p>
<p><img src="img/0e54148261dedc6043a7d9fd5d8fa3dd.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/KX6abaf8Rofb4NxombTc2BUlnCd/"/></p>

<p><img src="img/3839bd4b6e08c421c090f1b87300077a.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/TziEb5QjDoWHLNxleygcJSTPnkc/"/></p>

<h3>使用指引</h3>
<p>完成以上准备之后，打开软件</p>

<p>① 输入代理地址（并保存）</p>
<p><img src="img/e90fc09c422bd0f1455d7403293d56a7.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/J3ykb1CTWodoYmxpJsUcAmemnoc/"/></p>

<p>② 选择存放视频链接的Excel文件</p>
<p><img src="img/7b917cdc8622c5e35da8408d663ee953.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/RaR1bUvW0oawo4xxGZUcC7T0nrd/"/></p>

<p>③ 选择下载后的视频的保存位置</p>
<p><img src="img/5240b1e41cc07591f18dd8415f534fcc.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/EPjObUN9GowOhXxWE4UctMGonec/"/></p>

<p>④选择保存cookies的txt文件</p>
<p><img src="img/4858939d8bbe112e7d6fad8d22e053ce.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/Os9DbTKgMoS83bxEi1UcU6NpnRb/"/></p>

<p>⑤ 选择要下载的视频分辨率</p>

<p>⑥ 选择要下载的视频数量</p>
<p>(右侧会显示在Excel文件中识别出了多少个可以下载的视频，输入n，就会下载前n个，程序会从上到下依次读取链接并下载，即将下载的视频链接会显示在下方文本框）</p>
<p><img src="img/352b14c1f2830e8046991f606594dab5.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/HwbkbF197oviZuxQuCkcDC8Hn9b/"/></p>

<p><img src="img/9fde81f2386431cfcdb4ff4c167b9c9f.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/HOWzbv8OroS4dPx96NDcWDtBnBc/"/></p>


<p>⑦ 开始下载</p>

<p>下载完毕之后，还会保存一个Excel列表（名字为“下载结果_具体下载时间”），里面标明各个视频是否成功下载</p>
<p><img src="img/9e4ad7f4d9a33ad5d77da4aecd1d3c10.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/LZzubgWBUovKiMxsbErciREAnGh/"/></p>

<h3>软件地址</h3>
<p>通过百度网盘分享的文件：Youtube批量视频下载.rar</p>
<p>链接：https://pan.baidu.com/s/1_zFUb72xeABeVpldlqambQ?pwd=xrmc</p>
<p>提取码：xrmc</p>

<h3>源代码</h3>
<h4>主程序</h4>
<pre>import yt_dlp
from tqdm import tqdm
import os
import pandas as pd
from concurrent.futures import ThreadPoolExecutor
import time


def get_format_option(resolution):
    """根据选择的分辨率返回格式选项"""
    resolution_map = {
        '720p': 720,
        '1080p': 1080,
        '1440p': 1440
    }
    height = resolution_map[resolution]
    # 添加编码格式限制，优先选择 H.264 编码
    return f'bestvideo[height&lt;={height}][vcodec^=avc]+bestaudio[ext=m4a]/best[height&lt;={height}]/best'


def batch_download(urls, output_path, resolution, proxy=None, progress_callback=None):
    """批量下载视频的函数"""
    results = []
    total = len(urls)
    completed = 0

    ydl_opts = {
        'format': get_format_option(resolution),
        'outtmpl': os.path.join(output_path, '%(title)s.%(ext)s'),
        'merge_output_format': 'mp4',
        'ignoreerrors': True,
        'quiet': True,
        'no_warnings': True,
        'format_sort': ['vcodec:h264'],
        # 使用aria2c作为外部下载器
        'external_downloader': 'aria2c',
        'external_downloader_args': [
            '--min-split-size=1M',  # 最小分片大小
            '--max-connection-per-server=16',  # 单个服务器最大连接数
            '--split=16',  # 单个文件分成16片下载
            '--max-concurrent-downloads=3',  # 同时下载数
            '--continue=true',  # 支持断点续传
            '--optimize-concurrent-downloads=true'  # 优化并发下载
        ]
    }

    if proxy:
        ydl_opts['proxy'] = proxy
        # 为aria2c也添加代理设置
        ydl_opts['external_downloader_args'].extend([
            f'--all-proxy={proxy}'
        ])

    # 添加下载进度回调
    def download_progress_hook(d):
        if d['status'] == 'downloading':
            try:
                downloaded = d.get('downloaded_bytes', 0)
                total_bytes = d.get('total_bytes') or d.get('total_bytes_estimate', 0)
                if total_bytes:
                    video_progress = downloaded / total_bytes
                    total_progress = (completed + video_progress) / total
                    if progress_callback:
                        progress_callback(total_progress, f"正在下载第 {completed + 1}/{total} 个视频")
            except Exception:
                pass

    ydl_opts['progress_hooks'] = [download_progress_hook]

    for i, url in enumerate(urls):
        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                ydl.download([url])
                results.append({
                    'URL': url,
                    '状态': '成功',
                    '信息': '下载成功'
                })
        except Exception as e:
            results.append({
                'URL': url,
                '状态': '失败',
                '信息': str(e)
            })

        completed += 1
        if progress_callback:
            progress_callback(completed / total, f"完成第 {completed}/{total} 个视频")

    return results


def read_urls_from_excel(file_path):
    """从Excel文件读取URL列表"""
    try:
        df = pd.read_excel(file_path)
        url_column = None
        for col in df.columns:
            if col.lower() == 'url':
                url_column = col
                print(f"找到URL列：{col}（第 {list(df.columns).index(col) + 1} 列）")
                break

        if url_column is None:
            print("错误：Excel文件中没有找到'URL'或'url'列")
            return None

        urls = df[url_column].dropna().tolist()
        return urls
    except Exception as e:
        print(f"读取Excel文件时出错: {str(e)}")
        return None


def save_results_to_excel(results, output_path):
    """保存下载结果到Excel文件"""
    try:
        df = pd.DataFrame(results)
        result_file = os.path.join(output_path, f'下载结果_{time.strftime("%Y%m%d_%H%M%S")}.xlsx')
        df.to_excel(result_file, index=False)
        print(f"\n下载结果已保存到: {result_file}")
    except Exception as e:
        print(f"保存结果文件时出错: {str(e)}")


def get_valid_path():
    """获取有效的保存路径"""
    while True:
        path = input("请输入保存视频的完整路径: ").strip()
        if not path:
            print("错误：请输入有效的保存路径！")
            continue

        path = os.path.abspath(path)

        try:
            if not os.path.exists(path):
                os.makedirs(path)
            if os.access(path, os.W_OK):
                return path
            else:
                print("错误：没有写入权限，请选择其他路径")
        except Exception as e:
            print(f"错误：无效的路径 ({str(e)})")


def get_resolution_choice():
    """获取用户选择的分辨率"""
    while True:
        print("\n请选择下载视频的分辨率：")
        print("1. 720p")
        print("2. 1080p")
        print("3. 1440p")
        choice = input("请输入选择（1-3）: ").strip()

        resolution_map = {
            '1': '720p',
            '2': '1080p',
            '3': '1440p'
        }

        if choice in resolution_map:
            return resolution_map[choice]
        print("无效的选择，请重新输入！")


def main():
    print("YouTube视频批量下载器")
    print("=" * 50)

    # 获取Excel文件路径
    while True:
        excel_path = input("请输入Excel文件的完整路径: ").strip()
        if os.path.exists(excel_path):
            break
        print("错误：文件不存在，请重新输入！")

    # 读取URL列表
    urls = read_urls_from_excel(excel_path)
    if not urls:
        print("无法从Excel文件中读取URL，请检查文件格式")
        return

    print(f"从Excel中读取到 {len(urls)} 个URL")

    # 获取保存路径
    save_path = get_valid_path()
    print(f"视频将保存到: {save_path}")

    # 获取分辨率选择
    resolution = get_resolution_choice()
    print(f"已选择下载分辨率: {resolution}")

    # 获取下载数量
    while True:
        try:
            max_videos = input(f"请输入要下载的视频数量（最大{len(urls)}个，直接回车下载全部）: ").strip()
            if not max_videos:
                max_videos = None
                break
            max_videos = int(max_videos)
            if 1 &lt;= max_videos &lt;= len(urls):
                break
            print(f"请输入1到{len(urls)}之间的数字！")
        except ValueError:
            print("请输入有效的数字！")

    # 执行批量下载
    results = batch_download(urls, save_path, resolution, max_videos)

    # 保存下载结果
    save_results_to_excel(results, save_path)

    # 显示统计信息
    success_count = sum(1 for r in results if r['状态'] == '成功')
    print(f"\n下载完成！成功: {success_count}/{len(results)}")


if __name__ == "__main__":
    main()</pre>
<h4>UI</h4>
<pre>import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import json
import os
from Youtube_Downloader import batch_download, read_urls_from_excel
from threading import Thread


class YoutubeDownloaderUI:
    def __init__(self, root):
        self.root = root
        self.root.title("YouTube视频批量下载器")
        self.root.geometry("900x800")  # 增加窗口高度以适应新添加的链接显示区域

        # 设置整体样式
        self.style = ttk.Style()
        self.style.configure('TFrame', background='#f0f0f0')
        self.style.configure('Header.TLabel', font=('Microsoft YaHei UI', 12, 'bold'), background='#f0f0f0')
        self.style.configure('TLabel', font=('Microsoft YaHei UI', 10), background='#f0f0f0')
        self.style.configure('TButton', font=('Microsoft YaHei UI', 10))
        self.style.configure('Download.TButton', font=('Microsoft YaHei UI', 11, 'bold'))

        # 加载保存的代理设置
        self.proxy_config_file = 'proxy_config.json'
        self.saved_proxy = self.load_proxy_config()

        self.urls = []
        self.setup_ui()
        self.setup_callbacks()

    def setup_ui(self):
        # 创建主容器
        main_container = ttk.Frame(self.root, padding="20", style='TFrame')
        main_container.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)

        # 标题
        title_label = ttk.Label(main_container, text="YouTube视频批量下载器",
                                style='Header.TLabel')
        title_label.grid(row=0, column=0, columnspan=3, pady=(0, 20))

        # 创建输入区域框架
        input_frame = ttk.LabelFrame(main_container, text="下载设置", padding="10")
        input_frame.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 20))

        # Excel文件选择
        ttk.Label(input_frame, text="Excel文件路径:").grid(row=0, column=0, sticky=tk.W, pady=8)
        self.excel_path = tk.StringVar()
        excel_entry = ttk.Entry(input_frame, textvariable=self.excel_path, width=60)
        excel_entry.grid(row=0, column=1, sticky=tk.W, padx=(10, 10))
        ttk.Button(input_frame, text="浏览", command=self.select_excel, width=15).grid(row=0, column=2)

        # 保存路径选择
        ttk.Label(input_frame, text="保存路径:").grid(row=1, column=0, sticky=tk.W, pady=8)
        self.save_path = tk.StringVar()
        save_entry = ttk.Entry(input_frame, textvariable=self.save_path, width=60)
        save_entry.grid(row=1, column=1, sticky=tk.W, padx=(10, 10))
        ttk.Button(input_frame, text="浏览", command=self.select_save_path, width=15).grid(row=1, column=2)

        # 代理设置
        ttk.Label(input_frame, text="代理地址:").grid(row=2, column=0, sticky=tk.W, pady=8)
        self.proxy = tk.StringVar(value=self.saved_proxy)
        proxy_entry = ttk.Entry(input_frame, textvariable=self.proxy, width=60)
        proxy_entry.grid(row=2, column=1, sticky=tk.W, padx=(10, 10))
        ttk.Button(input_frame, text="保存代理", command=self.save_proxy, width=15).grid(row=2, column=2)

        # 创建选项区域框架
        options_frame = ttk.LabelFrame(main_container, text="下载选项", padding="10")
        options_frame.grid(row=2, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 20))

        # 分辨率选择
        ttk.Label(options_frame, text="视频分辨率:").grid(row=0, column=0, sticky=tk.W, pady=8)
        self.resolution = tk.StringVar(value="1080p")
        resolution_frame = ttk.Frame(options_frame)
        resolution_frame.grid(row=0, column=1, sticky=tk.W, padx=(10, 0))

        resolutions = [("720p", "720p"), ("1080p", "1080p"), ("1440p", "1440p")]
        for i, (text, value) in enumerate(resolutions):
            ttk.Radiobutton(resolution_frame, text=text, variable=self.resolution,
                            value=value).grid(row=0, column=i, padx=20)

        # 下载数量设置
        ttk.Label(options_frame, text="下载数量:").grid(row=1, column=0, sticky=tk.W, pady=8)
        download_frame = ttk.Frame(options_frame)
        download_frame.grid(row=1, column=1, sticky=tk.W, padx=(10, 0))

        self.download_count = tk.StringVar()
        ttk.Entry(download_frame, textvariable=self.download_count, width=10).grid(row=0, column=0)
        self.max_videos_label = ttk.Label(download_frame, text="最多可以下载0个视频")
        self.max_videos_label.grid(row=0, column=1, padx=(20, 0))

        # 创建视频链接显示区域
        urls_frame = ttk.LabelFrame(main_container, text="视频链接列表", padding="10")
        urls_frame.grid(row=3, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 20))

        # 创建滚动文本框
        self.urls_text = tk.Text(urls_frame, height=6, width=80, font=('Microsoft YaHei UI', 9))
        scrollbar = ttk.Scrollbar(urls_frame, orient="vertical", command=self.urls_text.yview)
        self.urls_text.configure(yscrollcommand=scrollbar.set)

        self.urls_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))

        # 设置文本框只读
        self.urls_text.configure(state='disabled')

        # 创建进度显示区域
        progress_frame = ttk.LabelFrame(main_container, text="下载进度", padding="10")
        progress_frame.grid(row=4, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 20))

        self.progress_label = ttk.Label(progress_frame, text="准备就绪")
        self.progress_label.grid(row=0, column=0, columnspan=3, sticky=tk.W, pady=(0, 5))

        self.progress = ttk.Progressbar(progress_frame, length=800, mode='determinate')
        self.progress.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 5))

        self.status_label = ttk.Label(progress_frame, text="总进度: 0%")
        self.status_label.grid(row=2, column=0, columnspan=3, sticky=tk.W)

        # 下载按钮
        self.download_button = ttk.Button(main_container, text="开始下载",
                                          command=self.start_download, style='Download.TButton', width=20)
        self.download_button.grid(row=5, column=0, columnspan=3, pady=10)

    def setup_callbacks(self):
        """设置回调函数"""

        def on_download_count_change(*args):
            if self.urls:
                self.update_urls_display()

        self.download_count.trace_add("write", on_download_count_change)

    def update_urls_display(self):
        """更新视频链接显示"""
        self.urls_text.configure(state='normal')
        self.urls_text.delete(1.0, tk.END)

        count = int(self.download_count.get()) if self.download_count.get() else len(self.urls)
        count = min(count, len(self.urls))

        for i, url in enumerate(self.urls[:count], 1):
            self.urls_text.insert(tk.END, f"{i}. {url}\n")

        self.urls_text.configure(state='disabled')

    def load_proxy_config(self):
        try:
            if os.path.exists(self.proxy_config_file):
                with open(self.proxy_config_file, 'r') as f:
                    config = json.load(f)
                    return config.get('proxy', '')
        except Exception:
            pass
        return ''

    def save_proxy(self):
        proxy = self.proxy.get()
        try:
            with open(self.proxy_config_file, 'w') as f:
                json.dump({'proxy': proxy}, f)
            messagebox.showinfo("成功", "代理设置已保存")
        except Exception as e:
            messagebox.showerror("错误", f"保存代理设置失败: {str(e)}")

    def select_excel(self):
        filename = filedialog.askopenfilename(
            filetypes=[("Excel files", "*.xlsx *.xls")]
        )
        if filename:
            self.excel_path.set(filename)
            self.urls = read_urls_from_excel(filename) or []
            self.max_videos_label.config(text=f"最多可以下载{len(self.urls)}个视频")
            self.update_urls_display()

    def select_save_path(self):
        path = filedialog.askdirectory()
        if path:
            self.save_path.set(path)

    def update_progress(self, progress, status_text):
        """更新进度显示"""
        self.progress['value'] = progress * 100
        self.progress_label.config(text=status_text)
        self.status_label.config(text=f"总进度: {progress:.1%}")
        self.root.update_idletasks()

    def validate_inputs(self):
        if not self.excel_path.get():
            messagebox.showerror("错误", "请选择Excel文件")
            return False
        if not self.save_path.get():
            messagebox.showerror("错误", "请选择保存路径")
            return False
        if not self.urls:
            messagebox.showerror("错误", "Excel文件中没有找到有效的URL")
            return False

        try:
            count = int(self.download_count.get() or len(self.urls))
            if count &lt;= 0 or count &gt; len(self.urls):
                messagebox.showerror("错误", f"下载数量必须在1到{len(self.urls)}之间")
                return False
            self.update_urls_display()
        except ValueError:
            messagebox.showerror("错误", "请输入有效的下载数量")
            return False

        return True

    def start_download(self):
        if not self.validate_inputs():
            return

        self.download_button.state(['disabled'])
        Thread(target=self.download_thread).start()

    def download_thread(self):
        try:
            count = int(self.download_count.get() or len(self.urls))
            proxy = self.proxy.get()

            def progress_callback(progress, status):
                self.root.after(0, self.update_progress, progress, status)

            results = batch_download(
                self.urls[:count],
                self.save_path.get(),
                self.resolution.get(),
                proxy=proxy,
                progress_callback=progress_callback
            )

            success_count = sum(1 for r in results if r['状态'] == '成功')
            messagebox.showinfo("完成", f"下载完成！成功: {success_count}/{len(results)}")

        except Exception as e:
            messagebox.showerror("错误", f"下载过程中出错: {str(e)}")

        finally:
            self.download_button.state(['!disabled'])
            self.status_label.config(text="就绪")
            self.progress_label.config(text="")
            self.progress['value'] = 0


def main():
    root = tk.Tk()
    app = YoutubeDownloaderUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()</pre>

<h1>开发过程（待补充，在写了在写了）</h1>

<h1>尾声</h1>
<p>之所以开发这两个软件，一开始是因为我学完了AI编程航海手册，同时通过圈友们发现cursor的妙处，打算用cursor开发几个软件练练手，结果效果还不错</p>

<p>开发完之后，一开始是蛮激动的，在生财还立了flag，要分享给圈友们一起用</p>
<p><img src="img/efa32ad387355ac037d3b99db5e2bfb7.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/FmeAbRM5co00Nzxtk6lc0i4ynVN/"/></p>

<p>但后面看到很多圈友分享cursor的教程，感觉自己再分享开发过程的话就有点重复，就没有动力了哈哈哈</p>

<p>软件一开始是只写了python脚本，没有封装，如果分享给大家用的话，肯定不能那么简陋，而且只给python脚本的话，不了解编程的圈友用起来就会比较困难</p>

<p>但一想到要继续开发UI界面，要优化打包，感觉复杂，就想偷懒了（bushi）</p>

<p>幸好有 彭哥@老彭  的督促，今天趁着有空就光速优化封装+写帖子分享</p>
<p><img src="img/bacb3763b7a0a63156488daa9f1510eb.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/DFdubx5CtoF9ZbxcgyQcfeYknjf/"/></p>

<p>当然，为了避免重复，这篇文章会以以工具分享为主，开发过程后面补充（cursor按项目开聊天，导致很多聊天我找不到了哈哈哈），先把工具分享给大家使用</p>

<p>如果这两个软件对大家有帮助的话，期待大家的反馈~</p>
<p>点赞、评论或者提供优化建议都可以！！！</p>
<h1>感谢</h1>
<p>感谢 彭哥@老彭  的督促，不然这个帖子可能遥遥无期哈哈哈</p>

<p>感谢 马哥@老馬🐎内容出海 在 这篇文章中分享的方法（调用Youtube官方api采集数据），我第一个软件的思路就是来自于马哥</p>

<p>感谢 @阿紫 分享的 和 @Time 分享的《0代码AI编程重塑你的编程体验：Cursor使用教程》，我自己摸索cursor就是看的这两个教程哈哈哈</p>

<p>感谢 @阿威 告诉我python有一个下载youtube视频的yt_dlp库，不然我可能就开发在线下载网站去了</p>

<p>感谢 @红哥Frank 分享的Youtube在线网站开发过程，我一开始以为youtube的视频分辨率只有1080p，看了红哥的帖子才知道有1440p以及更高</p>



