# 小白 1 小时搞定 2000 字专业文章

> 原文：[`www.yuque.com/for_lazy/zhoubao/ph3e8vla0a6y8igg`](https://www.yuque.com/for_lazy/zhoubao/ph3e8vla0a6y8igg)

## (10 赞)小白 1 小时搞定 2000 字专业文章

作者： 小飞侠

日期：2024-07-18

最近在学习明白老师的基础写作课，
同时，朋友想学习向量数据库 Milvus，
我就想，能不能两者结合一下

一是巩固，
二是也是帮朋友一下，
这篇文章，演示如何用 Milvus，实现 RAG。

# 什么是 RAG

RAG 系统结合了检索系统和生成模型,基于给定的提示生成新的文本。该系统首先使用 Milvus 从语料库中检索相关文档,然后使用生成模型基于检索到的文档生成新的文本。具体来说:

*   1.

RAG 系统包含两个主要部分:检索系统和生成模型。

*   2.

检索系统使用 Milvus 向量数据库来存储和检索文档。Milvus 可以高效地进行相似性搜索,从大规模语料库中快速找到与查询相关的文档。

*   3.

当系统收到一个提示或查询时,它首先使用 Milvus 检索最相关的文档。这个过程利用了 Milvus 的向量相似度搜索能力。

*   4.

检索到相关文档后,系统将这些文档连同原始提示一起传递给生成模型。

*   5.

生成模型(通常是一个大型语言模型)会基于检索到的文档内容和原始提示生成新的文本。这确保了生成的内容既相关又信息丰富。

*   6.

通过这种方式,RAG 系统可以生成基于最新和最相关信息的回答,而不仅仅依赖于预训练的知识。

这种方法充分利用了 Milvus 在高维向量检索方面的优势,使 RAG 系统能够从大规模数据集中快速准确地检索相关信息,从而提高生成内容的质量和相关性。

# Milvus 如何实现 RAG

第 1 步，安装 pymilvus 包

textjavascripttypescriptcsshtmlbashjsonmarkdownpythonjavaccpprubygorustphpsqlyaml Copy

```
pip install --upgrade pymilvus openai requests tqdm
```

第 2 步，配置 Openai 的 API key

textjavascripttypescriptcsshtmlbashjsonmarkdownpythonjavaccpprubygorustphpsqlyaml Copy

```
import osos.environ["OPENAI_API_KEY"] = "sk-***********"
```

第 3 步：导入明白老师的 38 节写作基础课，文字稿

textjavascripttypescriptcsshtmlbashjsonmarkdownpythonjavaccpprubygorustphpsqlyaml Copy

```
import jsonimport urllib.request
file_path = "Mingbai_writing.txt"

if not os.path.exists(file_path):

    urllib.request.urlretrieve(url, file_path)
```

第 4 步：按照章节把文档进行拆分，也就是 Markdown 的"# "符号

textjavascripttypescriptcsshtmlbashjsonmarkdownpythonjavaccpprubygorustphpsqlyaml Copy

```
with open(file_path, "r") as file:    file_text = file.read()

text_lines = file_text.split("# ")
```

第 5 步：定义了一个名为`emb_text`的函数，用于生成文本嵌入。这个函数的作用是将输入的文本转换为数值向量（嵌入），这个向量捕捉了文本的语义信息。这种嵌入可以用于各种自然语言处理任务，如语义搜索、文本分类或聚类分析等。使用"text-embedding-3-small"模型可以在效率和性能之间取得良好的平衡。

textjavascripttypescriptcsshtmlbashjsonmarkdownpythonjavaccpprubygorustphpsqlyaml Copy

```
def emb_text(text):

return (

    openai_client.embeddings.create(input=text, model="text-embedding-3-small")

    .data[0]

    .embedding
)
```

第 6 步：创建 Collection，如果已经存在，就丢弃。如果我们不指定任何字段信息,Milvus 会自动创建以下内容: 一个默认的 id 字段作为主键 一个向量字段用于存储向量数据 一个保留的 JSON 字段,用于存储未在 schema 中定义的字段及其值 这种自动创建的默认结构为用户提供了便利,无需手动定义每个字段就可以快速开始使用 Milvus。同时,保留的 JSON 字段也提供了灵活性,允许存储一些额外的、未在 schema 中预先定义的数据。这对于处理动态或不确定的数据结构非常有用。

textjavascripttypescriptcsshtmlbashjsonmarkdownpythonjavaccpprubygorustphpsqlyaml Copy

```
from pymilvus import MilvusClientmilvus_client = MilvusClient(uri="./milvus_demo.db")

collection_name = "my_rag_collection"

if milvus_client.has_collection(collection_name):

milvus_client.drop_collection(collection_name)milvus_client.create_collection(

    collection_name=collection_name,

    dimension=embedding_dim,

    metric_type="IP",  # Inner product distance

    consistency_level="Strong",  # Strong consistency level

)
```

第 7 步：遍历文本行,创建嵌入向量,然后将数据插入到 Milvus 中。 这里有一个新字段 text,它在集合模式中是未定义的字段。它将被自动添加到保留的 JSON 动态字段中,在高层次上可以被视为一个普通字段。 这段话解释了以下几点: 处理数据的过程:遍历文本,为每行创建嵌入向量,然后将数据插入 Milvus。 引入了一个新字段"text",这个字段在原始的集合模式(schema)中并未定义。 尽管"text"字段未在模式中定义,但由于启用了动态字段功能,它会被自动添加到一个保留的 JSON 动态字段中。 虽然"text"是动态添加的字段,但在使用时可以像普通预定义字段一样对待它。 这体现了 Milvus 的动态模式特性,允许在不修改原始模式的情况下灵活地添加新字段,提高了数据插入和管理的灵活性。

textjavascripttypescriptcsshtmlbashjsonmarkdownpythonjavaccpprubygorustphpsqlyaml Copy

```
from tqdm import tqdmdata = []

for i, line in enumerate(tqdm(text_lines, desc="Creating embeddings")):

    data.append({"id": i, "vector": emb_text(line), "text": line})

milvus_client.insert(collection_name=collection_name, data=data)
```

第 8 步：在集合中搜索问题并检索语义上最相似的前 3 个匹配结果。 这段代码的具体含义是： 使用 milvus_client.search 方法在指定的集合中进行搜索。 搜索的数据是将输入的问题(question)通过 emb_text 函数转换成的嵌入向量。 limit=3 表示返回相似度最高的前 3 个结果。 搜索参数使用内积（Inner Product, IP）作为相似度度量方法。 output_fields=["text"]指定返回结果中包含"text"字段。 这种搜索方法利用了向量相似度来找到语义上最接近的匹配，而不是简单的关键词匹配，因此能够检索到语义上相关的结果。

textjavascripttypescriptcsshtmlbashjsonmarkdownpythonjavaccpprubygorustphpsqlyaml Copy

```
question = "为什么要写作"search_res = milvus_client.search(

collection_name=collection_name,

data=[

    emb_text(question)

],  # Use the `emb_text` function to convert the question to an embedding vector

limit=3,  # Return top 3 results

search_params={"metric_type": "IP", "params": {}},  # Inner product distance

output_fields=["text"],  # Return the text field)

retrieved_lines_with_distances = [

    (res["entity"]["text"], res["distance"]) for res in search_res[0]

]

print(json.dumps(retrieved_lines_with_distances, indent=4))
```

第 9 步：这个用户提示为语言模型提供了具体的指令: 它指示模型使用标签中的信息来回答问题。 {context}是一个占位符,将被从 Milvus 检索到的相关文档填充。 {question}是一个占位符,将被用户的具体问题替换。 这种提示结构的设计目的是: 为语言模型定义系统级行为(作为能回答问题的 AI 助手)。 提供一个结构化的格式,将检索到的上下文信息和用户问题传递给模型。 指导模型使用提供的上下文来回答特定问题,而不是依赖其预训练知识。 这种方法结合了检索增强生成(RAG)技术,通过从 Milvus 检索相关文档来增强语言模型的回答能力。

textjavascripttypescriptcsshtmlbashjsonmarkdownpythonjavaccpprubygorustphpsqlyaml Copy

```
context = "\n".join(    [line_with_distance[0] for line_with_distance in retrieved_lines_with_distances]

)

SYSTEM_PROMPT = """
Human: You are an AI assistant. You are able to find answers to the questions from the contextual passage snippets provided.
"""

USER_PROMPT = f"""
Use the following pieces of information enclosed in <context> tags to provide an answer to the question enclosed in <question> tags.
<context>
{context}
</context>
<question>
{question}
</question>
"""

response = openai_client.chat.completions.create(

model="gpt-3.5-turbo",

messages=[

    {"role": "system", "content": SYSTEM_PROMPT},

    {"role": "user", "content": USER_PROMPT},

],)

print(response.choices[0].message.content)
```

检索到的 context 是： ![](img/f4c34af42154348106477288212dc87b.png)  

我想了解，是什么让明白老师坚定日更 1000 天，我输入的问题是"为什么写作"。我得到的答案是：

写作对于普通人来说，是一个重要的基础技能。通过写作，可以提高赚钱效率和概率，促进个人成长和提升。通过深入思考写作的意义和价值，可以帮助人们更有方向、更有效率地写作，并从中获得更大的收益。写作不仅仅是一种技能，更是一个系统，需要输入、思考、输出等多个因素相结合。通过持续写作，一个人的能力和价值也会不断提高，最终实现个人成长和收益的目标。

完整代码联系索取。

# 总结

我大概用了 1.5 半小时是实现这个代码，中间遇到了安装包冲突等问题，明白老师的 38 节课程，完全手工复制，加工，大概用了 20 分钟，也就是 1 个小时，就能实现个人知识库。Milvus 使用起来，还是非常方便。

收集素材是写作的基础，火爆标题，金句，在日常生活中收集，然后建立自己的知识库，快速查询，还是很方便的。

* * *

评论区：

暂无评论

![](img/21de372a77ea1f441c613f7316831ae1.png "None")

* * *